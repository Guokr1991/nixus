@i boilerplate.w


\datethis
\def\title{NIXUS}

@* Introduction. The word \title, that means strain in Latin, is the
name of the project to manipulate RF files generated by Ultrasonix
SonixRP system containing ultrasound scan lines in raw format. The
objective of this project is to measure displacements in the material
being scanned using differences in the RF frames obtained during the 
scan.
  
@p
@<Header files@>@;
@<Macro declarations@>@;
@<Type definitions@>@;
@<Prototypes@>@;
@<Private variables@>@;
@<Internal functions@>@;
@<Memory management@>@;
@<Functions@>@;
@<Test procedures@>@;

int main(argc, argv) 
     int argc;
     char**argv;
{
#if 1==2
  test_match();
#endif
  test_xcorr2d();

  return 0;
}

@ Common header files.
@<Header...@>=
#include <assert.h>
#include <errno.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

@ We make some aliases for common types to know 
the wide in bits.

@<Type def...@>=
  typedef unsigned long long int Uint64;
typedef long long Int64;
typedef unsigned int Uint32;
typedef int Int32;
typedef unsigned short Uint16;
typedef short Int16;
typedef unsigned char Uint8;
typedef char Int8;
typedef double Float;

@* Ultrasonix. There is a rich bunch image formats that can be produced by 
  Ultrasonix equipment. The |u_file_header| contains information needed
  to extract data properly. The |type| variable is assigned to |u_data_type| 
  and in this project, the type of interest is |udtRF|.

@<Type...@>=
  enum u_data_type{
  udtScreen= 0x00000001, /* Compressed file of screen captures */
  udtBPre= 0x00000002, /* Envelope detected B data */
  udtBPost= 0x00000004, /* Interpolated and post-processed B data */
  udtBPost32= 0x00000008, /* Interpolated and post-processed B data 32 bit */
  udtRF= 0x00000010, /* Pre or Post-beamformed RF data */
  udtMPre= 0x00000020, /* Envelope detected and log-compressed M lines */
  udtMPost= 0x00000040,/* Interpolated M line data stored as a single spectrum capture */
  udtPWRF= 0x00000080, /* Doppler RF gate data acquired at the Doppler PRF */
  udtPWSpectrum= 0x00000100, /* Interpolated FFT data stored as a single spectrum capture */
  udtColorRF= 0x00000200, /* Color RF data acquired at the Color PRF with full packet-size */
  udtColorCombined= 0x00000400, /* Interpolated and processed B and color data */
  udtColorVelocityVariance= 0x00000800, /* Interpolated and processed color velocity (Y) 
					   and variance data (X). Variance is power data in 
					   Power Doppler mode  */
  udtElastoCombined= 0x00002000, /* Interpolated and processed B and elastography data */
  udtElastoOverlay= 0x00004000, /* Interpolated and processed elastography data */
  udtElastoPre= 0x00008000, /* Midway processed elastography data before interpolation, 
			       and after RF and strain conversion */
  udtECG= 0x00010000, /*ECG spectrum data */
  udtGPS= 0x00020000, /* GPS co-ordinate data */
  udtPNG= 0x10000000 /* PNG data ?*/
};

typedef struct u_file_header {
  enum u_data_type type; /* data type (can be determined by file extensions) */
  int frames; /* number of frames in file */
  int w;      /* width (number of vectors for raw, 
		image width for processed data) */
  int h;      /* height (number of samples for raw, 
		 image height for processed data) */
  int ss;     /* data sample size in bits */
  int ulx;    /* roi - upper left (x) */
  int uly;    /* roi - upper left (y) */
  int urx;    /* roi - upper right (x) */
  int ury;    /* roi - upper right (y) */
  int brx;    /* roi - bottom right (x) */
  int bry;    /* roi - bottom right (y) */
  int blx;    /* roi - bottom left (x) */
  int bly;    /* roi - bottom left (y) */
  int probe;  /* probe identifier - additional probe information 
		 can be found using this id */
  int txf;    /* transmit frequency in Hz */
  int sf;     /* sampling frequency in Hz */
  int dr;     /* data rate (fps or prp in Doppler modes) */
  int ld;     /* line density (can be used to calculate element spacing if
		 pitch and native number of elements is known  */
  int extra;  /* extra information (ensemble for color RF) */
} U_FileHeader;

@ The {\tt u\_*} macros are defined to access Ultrasonix file header
information, acting as interface and avoiding direct access to
variables.

@d u_nframes(ufh) ufh->frames
@d u_frame_width(ufh) ufh->w
@d u_frame_height(ufh) ufh->h
@d u_sample_size(ufh) ufh->ss /* sample size in bits */

@ @<Proto...@>=
 extern void u_print_file_header(U_FileHeader*ufh);

@ The |u_print_file_header| function prints the information about
Ultrasonix file and is useful to debug purposes.
@<Functions@>=
void u_print_file_header(U_FileHeader *h){
  printf("Header information:\n");
  printf("|- data type: %d\n",h->type);
  printf("|- number of frames: %d\n",h->frames);
  printf("|- width (number of vectors): %d\n",h->w);
  printf("|- height (number of samples): %d\n",h->h);
  printf("|- data sample size in bits: %d\n",h->ss);
  printf("|- roi - upper left (x): %d\n",h->ulx);
  printf("|- roi - upper left (y): %d\n",h->uly);
  printf("|- roi - upper right (x): %d\n",h->urx);
  printf("|- roi - upper right (y): %d\n",h->ury);
  printf("|- roi - bottom right (x): %d\n",h->brx);
  printf("|- roi - bottom right (y): %d\n",h->bry);
  printf("|- roi - bottom left (x): %d\n",h->blx);
  printf("|- roi - bottom left (y): %d\n",h->bly);
  printf("|- probe identifier: %d\n",h->probe);
  printf("|- transmit frequency (Hz): %d\n",h->txf);
  printf("|- sampling frequency (Hz): %d\n",h->sf);
  printf("|- data rate: %d\n",h->dr);
  printf("|- line density: %d\n",h->ld);
  printf("|- extra information: %d\n",h->extra);
  printf("|- number of bytes per frame: %d\n", 4 + h->w * h->h * h->ss/8);
  printf("|- number of pixels per frame: %d\n", 4 + h->w * h->h);

  return;
}


@* RF. Pre or post-beamformed RF image has the following specification.
\bigskip
  \settabs 16 \columns
    \+&Type: {RF}\cr
  \+&Description: Pre or Post-beamformed RF data\cr
  \+&Organization: Vector\cr
  \+&Bytes per pixel/Format: 16/RF\cr
  \+&Frame size FC + (V * S * 2)\cr
  \+&Extension: .rf\cr
  \+where,\cr
  \+&FC=4 byte header\cr
  \+&V=vectors (number of scan lines)\cr
  \+&S=samples (number of incident pulses per scan line line represented by 2-byte header).\cr

\bigskip
RF file is loaded into memory as |RF|, saving the |file_header|
information and the pixels into |data|. The |area| is part of a memory
management scheme used by SGB (Stanford GraphBase). The concept of
type |Area| is simple and powerful because all memory allocations are
performed using |gb_typed_alloc| function, also from SGB, allowing
safe and unique deallocation.

@<Type...@>=
typedef struct rf {
  U_FileHeader *file_header; /* header with file and RF information */
  pixel_t *data; /* array containing pixel values */
  struct arena *arena;
} RF;

@ Private variable |cur_rf| is used to maintain a internal global
pointer to pass |RF| through the program.
@<Private...@>=
  static RF *cur_rf;

@ Each RF pixel is 2-byte size (16 bits). |MAX_PIX_VAL| ($2^{15}-1$)
  is the maximum pixel value that can be assigned to RF sample. The
  minimum pixel value is 32,767 ($2^{15}$). This range is due the type
  assigned to |pixel_t|. The type can be changed according to the
  pixel manipulation needs, but a careful attention must be paid to
  assigned correct values for limits.

@<Macro...@>=
#ifdef pixel_t
#undef pixel_t
#endif
#define pixel_t Uint16
#define MAX_PIX_VAL 65535


@ Some macros to access RF information are defined to expose
a clean accession interface.

@d RF_FRAME_HEADER_SZ 4 /* 4-byte frame header */
@d RF_FRAME_HEADER_NPIX 2 /* number of pixels in the frame header (each pixel is 2-byte) */
@d rf_frame_nvectors(rf) u_frame_width(rf->file_header)
@d rf_frame_nsamples(rf) u_frame_height(rf->file_header)
@d rf_nframes(rf) u_nframes(rf->file_header)
@d rf_frame_npixels(rf) (RF_FRAME_HEADER_NPIX +
  rf_frame_nvectors(rf)*rf_frame_nsamples(rf)) /* in  pixels\_t */
@d rf_frame_nbytes(rf) (rf_frame_npixels(rf)*RF_FRAME_HEADER_NPIX) /* in bytes */
@d rf_npixels(rf) ((rf_frame_npixels(rf))*rf_nframes(rf))
@d rf_nbytes(rf) (rf_npixels(rf)*RF_FRAME_HEADER_NPIX) /* in bytes */

@*1 {RF data}.The lines are recorded as showed in the
Figure~1, where each sample is recorded as it arrives, and
after all, the map must be reshaped where the coordinate $(0,1)$
becomes $(1,0)$, for example, reconstructing the RF data as it is
  formed after processing in B-mode. (See notes)
  
@ A pixel at position $(x, y)$ on frame number $FN$ is obtained by:

  $$FN = npp + npfh + x\times nsv + y,$$

where
\settabs 16\columns
\+&$npp$& -  &number of pixels per frame;\cr
\+&$npfh$& -  &number of pixels in the frame header;\cr
\+&$nsv$& - &number of samples per vector;\cr
\+&$x$& - &x position;\cr
\+&$y$& - &y position.\cr
\bigskip

  The pixel value can be obtained by using |rf_pixel| macro, and all information needed
  is available in the RF file header. Remember the value on y axis goes from $0$ to $h$,
  from top to bottom, a common standard when dealing with images to simplify the 
  image transverse reasoning. (See notes)


  The |rf_pixel_prt| returns the address of the pixel in the $(x,y)$
  position of the |frame_id|. The mapping of RF as showed in
  Figure~1 (scan lines) to RF as showed in
  Figure~2 (image) is done to access the right pixel at
  the desired position.

@d rf_pixel_ptr(rf, frame_no, x, y) (rf->data		
+ rf_frame_npixels(rf)*frame_no				
+ RF_FRAME_HEADER_NPIX				
+ (x)*rf_frame_nsamples((rf))			
+ (y))
@d rf_pixel(rf, frame_no, x, y) *rf_pixel_ptr(rf, frame_no, x, y)

@<Functions@>=
RF *rf_new () 
{
  cur_rf = calloc(1, sizeof(RF));
  assert(cur_rf);

  cur_rf->arena = arena_new();
  assert(cur_rf->arena);

  cur_rf->file_header = arena_alloc(cur_rf->arena, sizeof(U_FileHeader));

  return cur_rf;
}

@ @<Functions@>=  
void rf_free(rf)
     RF *rf;
{
  assert(rf);

  arena_dispose(&(rf->arena));    
  free(rf);
}

@ @<Functions@>=
RF *rf_read(fn)
const char*fn; /* RF file name */
{
  FILE *fp;
  RF *rf;

  assert(fn);
  rf = rf_new();
  
  if ((fp = fopen(fn, "rb")) == NULL)
      die("Could not open the file %s: %s\n", fn, strerror(errno));

  @<Extract and print RF file header@>@;
  @<Allocate memory and fill with RF data@>@;
  
  fclose(fp);
    
  assert(rf_nframes(rf)>0);

  return rf;
  
}

@ File header is read to extract information about the 
  RF data incorporated, then it is printed to inform 
  how data is structured.
@<Extract and print RF file header@>=
      fread(rf->file_header, sizeof(U_FileHeader), 1, fp);
if (rf->file_header->type != udtRF)/* verify if the file is RF type 0x10 = 16 */
  die("The file %s seems not to be in RF format.\n", fn);
u_print_file_header(rf->file_header);

@ A quantity |data_sz| of memory for |rf_data| is allocated in the heap and 
  filled with binary data obtained from RF file. The |rf_data| contains
  all RF frame headers and frames.

@<Allocate memory and fill with RF data@>=
  rf->data = (pixel_t *)arena_alloc(rf->arena, rf_nbytes(rf));

if (!rf->data) {
  rf_free(rf);
  
  die("Could not allocate memory.");
 }
fread(rf->data, rf_nbytes(rf), 1, fp);

@* Memory allocation. Due the frequent use of dynamic memory
allocation, we implemented a memory management scheme to allow a
centralized source of access to the chunks of memory. This scheme is
known as |arena|, it was described by David R. Hanson in the 1997
edition of the book ``C Interfaces and Implementations'' at page 89.

This scheme avoid the need to allocate and free in the same excerpt of
code, and help to avoid the dangling pointer problem, when a pointer
is deallocated before its lifetime end. The memory is freed at the
same time in batch mode.

@<Type def...@>=
  typedef struct arena {
    struct arena *prev;
    Uint8 *avail;
    Uint8 *limit;
  } Arena;

@ @<Proto...@>=
  Arena *arena_new(void);
void arena_dispose(Arena**);
void *arena_alloc(Arena*, Int64 nbytes);
void *arena_calloc(Arena*, Int64 count, Int64 nbytes);
void arena_free(Arena*);

@ @<Memory...@>=
  Arena *arena_new()
{@+Arena *arena;
  arena = malloc(sizeof(Arena));
  assert(arena);

  arena->prev = NULL;
  arena->limit = arena->avail = NULL;
  return arena;
}

@ @<Memory...@>=
  void *arena_alloc(arena, nbytes) 
  Arena *arena;
Int64 nbytes;
{@+assert(arena);
  assert(nbytes>0);
 
@<Round |nbytes| up to the alignment boundary@>@;
  while (nbytes > arena->limit - arena->avail) {
    @<Get a new chunk@>@;
  }
  
  arena->avail += nbytes;
  return arena->avail - nbytes;
}

@ @<Type def...@>=
      union align {
	int i;
	long l;
	long *lp;
	void *p;
	void (*fp)(void);
	float f;
	double d;
	long double ld;
      };

@ @<Get a new chunk@>=
      Arena *ptr;
Uint8 *limit;
@<A new chunk is assigned to |ptr|@>@;
*ptr = *arena;
arena->avail = ((Uint8 *)(union header *)ptr + 1);
arena->limit = limit;
arena->prev = ptr;

@ @<Type def...@>=
  union header {
    Arena *b;
    union align a;
  };

@ @<Internal...@>=
  static Arena *freechunks;
static Int64 nfree;

@ @<A new chunk is assigned to |ptr|@>=
  if ((ptr=freechunks) != NULL) {
    freechunks = freechunks->prev;
    nfree--;
    limit = ptr->limit;
  } else {
    Int64 m = sizeof(union header) + nbytes + 10*1024;
    ptr = calloc(1,m);
    assert(ptr);
    limit = (Uint8 *)ptr + m;
  }

@ @<Round |nbytes| up to the alignment boundary@>=
      nbytes = ((nbytes + sizeof(union align) - 1)/
		(sizeof(union align)))*(sizeof(union align));

@ @<Memory...@>=
  void *arena_calloc(arena, count, nbytes)
  Arena *arena;
Int64 count, nbytes;
{@+void *ptr;
  
  ptr = arena_alloc(arena, count*nbytes);
  return ptr;
}

@ @<Memory...@>=
      void arena_free(arena) 
      Arena *arena;
{
  assert(arena);
  
  while (arena->prev) {
    Arena *tmp = arena->prev;
    @<Free the chunk described by |arena|@>@;
    arena = tmp;
  }
  assert(arena->limit == NULL);
  assert(arena->avail == NULL);
}

@ @d THRESHOLD 10
@<Free the chunk described by |arena|@>=
      if (nfree < THRESHOLD) {
	arena->prev->prev = freechunks;
	freechunks = arena->prev;
	freechunks->limit = arena->limit;
      } else
	free(arena->prev);

@ @<Memory...@>=
  void arena_dispose(apt) 
  Arena **apt;
      {
	assert(apt);
	assert(*apt);
	
	arena_free(*apt);
	free(apt);
	*apt=NULL;
      }


@* Normalized Cross-Correlation ($r_{xy}$). NCC is frequently used as a
method to determine correlation between two data series. This method
is used to calculate the pairwise correlation between RF
sub-frames. The reference data is compared with template, where the
template in our case is the RF images acquired normally after some
deformation is induced in the sample exposed to ultrasound pulse.

$$
\def\dt{{\Delta~t}}
\def\average#1{\overline{#1}}
r_{xy}= {
  {\sum\limits_{i=1}^{n}
   (x_i-\average{x})(y_i- \average{y})
  }\over
  {\sqrt{\sum\limits_{i=1}^{n}(x_i-\average{x})^2
	 \times\sum\limits_{i=1}^{n}(y_i-\average{y})^2}}
}\eqno(1)
$$

\settabs 16 \columns
\+ where\cr
\+&$r_{xy}$~-~normalized cross-correlation;\cr
\+&$i$~--~index; \cr
\+&$x$~--~|REFERENCE| signal in pixel intensity;\cr
\+&$y$~--~|TARGET| signal to be compared with the reference in pixel intensity.\cr

\bigskip
The problem with Equation (1) is that requires two passes to calculate
the correlation. Equation (2) is less intuitive but it requires only 
one pass to acomplish the task. The equation was obtained from 
 the book ``Introduction to 64 Bit Intel Assembly Language Programming for
 Linux: Second Edition'' at chapter 19 (Kindle edition), by Ray Seyfarth.

$$
\def\den#1{{\sqrt{n\sum #1_i^2-(\sum #1_i)^2}}}
r_{xy} = {
       {n\sum x_iy_i-\sum x_i\sum y_i}
       \over
       {\den{x}\den{y}}
}\eqno(2)
$$

\noindent where the variables have the same meaning of Equation (1).

\bigskip
|REFERENCE| image index is assigned to $0$ and |TARGET| to 1. The
|REFERENCE| image is divided into sub-frames that are regions to be
tracked against the |TARGET| to find the differential strain. The
|struct coordinate| is a wrapper to $(x,y)$ coordinates.

@<Type...@>=
 enum {REFERENCE=0, TARGET=1};
typedef struct coordinate {
    Uint64 x;
    Uint64 y;
  } Coordinate;

typedef struct subframe {
   Uint64 frame_id; /* frame number */
   struct coordinate top_left; /* top left coordinate of sub-image */
   struct coordinate bottom_right; /* bottom right coordinate of sub-image */
 } SubFrame;


@ Using the Equation~(2), five sums are needed to pass the data:
$x_i$, $y_i$, $x_i^2$, $y_i^2$, $x_iy_i$.

@<Proto...@>=
  Float rf_xcorr2d(RF*rf, SubFrame *reference, SubFrame *target);
		       
@ @<Functions@>=
Float rf_xcorr2d(rf, ref, tar)
 RF *rf;	 /* RF data to work on */
 SubFrame *ref; /* reference sub-frame to track */
 SubFrame *tar; /* target sub-frame to calculate the correlation with reference */
{@+Uint64 dx, dy, n; /* how many pixels to transverse in x and y */
  register Uint64 x, y; /* x, y sub-frame coordinates */
  register Uint16 *px, *py;
  register Uint64 sum_x, sum_y, sum_xx, sum_yy, sum_xy;
  
  assert(rf!=NULL);
  assert(ref!=NULL);
  assert(tar!=NULL);

  @<Initialize |dx|, |dy|...@>@;

  for (y = 0; y < dy ; y ++ ) {
    for (x = 1; x < dx ; x++) {
      @<Update pixel values |px| and |py|@>@;
      sum_x += *px;
      sum_y += *py;
      sum_xx += *px * *px;
      sum_yy += *py * *py;
      sum_xy += *px * *py;
    }
  }
  n = dx; /* total number of pixels transversed */
  return ((Float)(n*sum_xy-sum_x*sum_y))/
    sqrt((n*sum_xx-sum_x*sum_x)* 
	 (n*sum_yy-sum_y*sum_y));
}  

@ @<Initialize |dx|, |dy| and assert the equivalence in geometry between sub-frames@>=
      dx = ref->bottom_right.x - ref->top_left.x;
dy = ref->bottom_right.y - ref->top_left.y;
assert ((ref->bottom_right.x - ref->top_left.x) == (tar->bottom_right.x - tar->top_left.x));
assert ((ref->bottom_right.y - ref->top_left.y) == (tar->bottom_right.y - tar->top_left.y));

@ @<Update pixel values |px| and |py|@>=
  px = rf_pixel_ptr(rf , ref->frame_id , ref->top_left.x + x, ref->top_left.y + y);
py = rf_pixel_ptr(rf , tar->frame_id , tar->top_left.x + x, tar->top_left.y + y);




@* Optimizations. The following prototypes are foreign to {\sc CWEB},
and for these reasons are generated in separated files ({\tt
asm/xcorr2d\_sse.asm} and {\tt asm/xcorr2d\_avx.asm}).  The files
contain instructions to calculate cross correlation using Intel x86-64
assembly language, more specifically the {\tt yasm} assembler.

The reason to use assembly language is not because we think we can
beat the compiler in the assembly code generated, but because some
operations and resources to process images implemented in the
processor, sometimes is not implemented as optmization in the
compiler.

The first implementation of cross correlation using Intel x86-64
  assembly ({\tt asm/xcorr2d\_sse.asm}) takes advantage of Streaming
  SIMD (single instruction, multiple data) Extensions (SSE) to perform
  some operations on multiple data. The second one ({\tt
  asm/xcorr2d\_avx.asm}) uses the Intel Advanced Vector Extensions
  (AVX).

The assembly code in the files was described by Ray Seyfarth in the
book ``Introduction to 64 Bit Intel Assembly Language Programming for
Linux: Second Edition'' at chapter 19 (Kindle edition).
\smallskip
@<Proto...@>=
  Float xcorr2d_sse(Float x[], Float y[], Uint64 n);
  Float xcorr2d_avx(Float x[], Float y[], Uint64 n);


@ The following program performs a trivial test
  using normalized cross correlation function.

@d NIXUS_TEST_XCORR2D_N 10000ULL

@<Test...@>=
  static int test_xcorr2d(void);
  static int test_xcorr2d()
  {
    Uint64 N = NIXUS_TEST_XCORR2D_N;
      pixel_t ref[N], targ[N]; /* reference and target */
      Uint64 i;
      Float xcorr=0.0;

      for (i = 0; i < N; i++) {
	ref[i] = i;
	//*(targ+i) = rand();
	targ[i] = ref[i] * 2;
      }
#if 1==2
      TODO redo the test reasoning
      xcorr = rf_xcorr2d(&ref, &targ);
#endif

      printf("Cross correlation=%f\n", xcorr);

      return 0;
    }




@* Sub-frame matching. Sub-frames are divisions of the |REFERENCE| RF
image that are used to search the most correlate region in the image
used as |TEMPLATE|. The |reference_id| indicates the number of the RF
frame to be used as |REFERENCE|, and the |target_id| is the same to
|TARGET| image. The |ratio| type set the value to divide the columns
and lines to obtain the sub-frames. Sub-frame is not called region of
interest (ROI) to avoid collision with the same term used in the RF
file header. 

@<Proto...@>=
void rf_match(RF*rf, Uint64 rid, Uint64 tid, struct ratio r);

@ @<Type...@>=
struct ratio {
  int x;
  int y;
};

@ The |rf_match| function transverse all sub-frames in the reference
image and find the coordinates of most correlate area in the target
image that represents the strain in the sample.

@<Function...@>=
  void rf_match(rf, reference_id, target_id, ratio)
  RF*rf; /* reference image */
  Uint64 reference_id; /* index of reference image */
  Uint64 target_id; /* target index of image to compare with reference */
  struct ratio ratio; /* ratio in the row and column */
  {
    register Float ncc=0;
    Uint64 i, dx=0, dy=0;
    Uint64 indices[2] = {reference_id, target_id}; 
    @<Local variables for |rf_match|@>@;

    @<Assert indices...@>@;

    debug("ratio(x,y)=(%d,%d)\n", ratio.x, ratio.y);

    dx = rf_frame_nvectors(rf)/(float)ratio.x; 
    dy = rf_frame_nsamples(rf)/(float)ratio.y; 
    
    debug("d(x,y)=(%llu,%llu)\n", dx, dy);

    @<Transverse the subdivisions in the reference image@>@;
    
    return;
  }

@ @<Assert indices are greater or equal than zero and not greater than
the number of frames@>=
  for (i=0; i<2; i++) {
    assert(indices[i] >= 0);
    assert(indices[i] < rf_nframes(rf));
  }

@ @<Local variables for |rf_match|@>=
  register Uint64 x, y, ncols, nrows;
  SubFrame *rsf, *tsf; /* temporary reference and target sub-frames */
  struct coordinate tl, br;
  

@ @<Transverse the subdivisions in the reference image@>=
  nrows = rf_frame_nsamples(rf);
  ncols = rf_frame_nvectors(rf);
  rsf = (SubFrame *)calloc(1, sizeof(SubFrame));
  tsf = (SubFrame *)calloc(1, sizeof(SubFrame));

  for (x=0; x<ncols; x+=dx)
    for (y=0; y<nrows; y+=dy) {
      @<Update reference subframe@>@;
      @<Find the best match in the target image@>@;
    }

@ @<Update reference subframe@>=
  tl.x=x;tl.y=y;
  br.x=x+dx;br.y=y+dy;
  subframe_new(rsf, reference_id, tl, br);

@ @<Local variables for |rf_match|@>=
  Uint64 xx, yy; /* indices for target subframe */

@ @<Find the best match in the target image@>=
  for (yy=x; yy+dy<nrows; yy++) {
    for (xx=y; xx+dx<ncols; xx++) {
      @<Update target subframe |tsf|@>@;
      ncc = rf_xcorr2d(rf, rsf, tsf);
      if (ncc > 0.9)
	debug("NCC(%llu.(%llu,%llu), %llu.(%llu, %llu))=%f\n", 
	      reference_id, x, y, target_id, xx, yy, ncc);
      if (xx==8) break;
    }
  }


@ @<Update target subframe...@>=
  tl.x=xx;tl.y=yy;
  br.x=xx+dx;br.y=yy+dy;
  subframe_new(tsf, target_id, tl, br);

@ @<Internal...@>=
  static void subframe_new(sf, frame_id, top_left, bottom_right)
  SubFrame *sf;
  Uint64 frame_id;
  struct coordinate top_left, bottom_right; /* top-left and bottom-right coordinates */
  {
    assert(sf != NULL);
    assert(top_left.x<bottom_right.x);
    assert(top_left.y<bottom_right.y);
    
    sf->frame_id = frame_id;
    sf->top_left = top_left;
    sf->bottom_right = bottom_right;
  }

@ @d RF_TEST_FILENAME "/opt/nixus/elasto/elasto.rf"
@<Test...@>=
@<Header...@>@;
  static int test_match(void);
  static int test_match()
  {
    RF *rf;
    struct ratio ratio = {.x=4, .y=8};
    ((void )0);
    
    rf = rf_read(RF_TEST_FILENAME);
    
    rf_match(rf, 0, 4, ratio);

    pgm_write(rf, 2, "/tmp/2.pgm");

    return 0;
  }


@* Portable Gray Map (PGM). PGM is used when there is a need to
inspect pixel value to debug the algorithms.

@<Internal...@>=
 static void pgm_write(rf, frame_no, output_filename)
    RF *rf; /* pointer to RF data */
    Uint16 frame_no; /* frame to be written */
    char *output_filename; /* file name to output */

  { FILE *fp;
    register Uint64 nrows, ncols; /* number of rows and columns of image */
    register Uint64 x, y; /* general purpose indices */
    pixel_t p;
    Float v;
    assert (rf);
    assert (output_filename);
    assert (rf->file_header);
    assert (rf->data);
    assert (frame_no >= 0);
    assert (frame_no < rf_nframes(rf));
    nrows = rf_frame_nsamples(rf);
    ncols = rf_frame_nvectors(rf);
    fp = fopen(output_filename, "w");
    if (!fp)
      die("Could not open \"%s\" file for writing.", output_filename);

    fprintf (fp, "P2\n");
    fprintf (fp, "# frame %u/%u\n", frame_no+1, rf_nframes(rf));
    fprintf (fp, "%llu %llu\n", ncols, nrows);
    fprintf (fp, "%d\n", MAX_PIX_VAL);

    for (y = 0; y < nrows; y++) {
      for (x = 0; x < ncols; x++)  {
	p = (pixel_t) rf_pixel(rf, frame_no,  x, y);
	
	v = (p + MAX_PIX_VAL)/65535.0 * 255.0;
	
	fprintf (fp, "%f\t%d\t", v, p);
      }
      fprintf(fp, "\n");
    }
    
    fclose(fp);
    return;
  }

@* Utilities. The macro |die| shows a message with the line number,
file and function names, and |abort| the execution of the program. If
|NDEBUG| macro is defined, no error is evaluated and no |debug|
information is printed.

@<Macro...@>=
#ifdef NDEBUG
#define debug_err(format, ...) ((void *)(0))
#define debug(format, ...) ((void *)0)
#else
#define debug(format, ...) do {						\
      fprintf(stdout, "%d:%s->%s(): ", __LINE__, __FILE__, __FUNCTION__);	\
      fprintf(stdout, format, ## __VA_ARGS__ );				\
    } while(0)
#define debug_err(format, ...)						\
  fprintf(stderr, "%s->%s: %d ", __FILE__, __FUNCTION__, __LINE__);	\
  fprintf(stderr, format, ## __VA_ARGS__)
#endif

#define die(format, ...)  do {						\
    debug_err(format, ## __VA_ARGS__);					\
    abort();								\
  } while(0)


@* TODO. The following tasks are pending, and the priority are
assigned in the parentheses.

\item{(0)} Refine the |rf_match| function to search a reasonable target
 image region, and step with a more accurate reasoning.
\item{(2)} Add multi-thread instructions in the target frames matching to take
 advantage of multi-core architecture of current processors.
\item{(4)} Implement the graphical interface with the elastography map. 


